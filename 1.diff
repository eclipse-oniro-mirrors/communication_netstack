diff --git a/frameworks/js/napi/socket/options/include/socket_remote_info.h b/frameworks/js/napi/socket/options/include/socket_remote_info.h
index e3842cf4256197c55b0738b859e341892fa24990..9f1503d4a20d88195c2779d2c888a935ced7c9f4 100644
--- a/frameworks/js/napi/socket/options/include/socket_remote_info.h
+++ b/frameworks/js/napi/socket/options/include/socket_remote_info.h
@@ -17,8 +17,8 @@
 #define COMMUNICATIONNETSTACK_SOCKET_REMOTE_INFO_H
 
 #include <cstdint>
-#include <string>
 #include <iosfwd>
+#include <string>
 
 #include "net_address.h"
 
@@ -37,6 +37,7 @@ public:
 
     void SetSize(uint32_t size);
 
+    void SetFamilyByStr(const std::string family);
     [[nodiscard]] const std::string &GetAddress() const;
 
     [[nodiscard]] const std::string &GetFamily() const;
diff --git a/frameworks/js/napi/socket/options/src/socket_remote_info.cpp b/frameworks/js/napi/socket/options/src/socket_remote_info.cpp
index 209713c038c73c3de60f58eb12d5ad7c3f232331..4e2334c5800c734302dac4c823f045a82c654f1d 100644
--- a/frameworks/js/napi/socket/options/src/socket_remote_info.cpp
+++ b/frameworks/js/napi/socket/options/src/socket_remote_info.cpp
@@ -15,8 +15,8 @@
 
 #include "socket_remote_info.h"
 
-#include <string>
 #include "sys/socket.h"
+#include <string>
 
 namespace OHOS::NetStack::Socket {
 SocketRemoteInfo::SocketRemoteInfo() : port_(0), size_(0) {}
@@ -57,6 +57,10 @@ const std::string &SocketRemoteInfo::GetFamily() const
     return family_;
 }
 
+void SocketRemoteInfo::SetFamilyByStr(const std::string family)
+{
+    family_ = family;
+}
 uint16_t SocketRemoteInfo::GetPort() const
 {
     return port_;
diff --git a/frameworks/js/napi/socket/socket_module/src/socket_module.cpp b/frameworks/js/napi/socket/socket_module/src/socket_module.cpp
index e8b8750fb8490c6eedb2fe626a87c4794fc469e9..84b5daaee27dbbd7e9fd00f312a7b2691f4b8cbb 100644
--- a/frameworks/js/napi/socket/socket_module/src/socket_module.cpp
+++ b/frameworks/js/napi/socket/socket_module/src/socket_module.cpp
@@ -40,6 +40,7 @@
 #include "tcp_extra_context.h"
 #include "tcp_send_context.h"
 #include "tlssocket_module.h"
+#include "tlssocketserver_module.h"
 #include "udp_extra_context.h"
 #include "udp_send_context.h"
 
diff --git a/frameworks/js/napi/tls/include/context/tls_connect_context.h b/frameworks/js/napi/tls/include/context/tls_connect_context.h
index 17671b7951bc0b442eafde66890a95a6d3331aa5..a4846240f4a37a25468dfa171a8a0a2d763cb546 100644
--- a/frameworks/js/napi/tls/include/context/tls_connect_context.h
+++ b/frameworks/js/napi/tls/include/context/tls_connect_context.h
@@ -49,6 +49,7 @@ private:
     TLSSecureOptions ReadTLSSecureOptions(napi_env env, napi_value *params);
     Socket::NetAddress ReadNetAddress(napi_env env, napi_value *params);
 };
+using TLSListenContext = TLSConnectContext;
 } // namespace TlsSocket
 } // namespace NetStack
 } // namespace OHOS
diff --git a/frameworks/js/napi/tls/include/context/tls_server_close_context.h b/frameworks/js/napi/tls/include/context/tls_server_close_context.h
new file mode 100644
index 0000000000000000000000000000000000000000..73c0d5e1008229590cd8f80418d705d3fd44b810
--- /dev/null
+++ b/frameworks/js/napi/tls/include/context/tls_server_close_context.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef TLS_CONTEXT_SEREVR_CLOSE_CONTEXT_H
+#define TLS_CONTEXT_SEREVR_CLOSE_CONTEXT_H
+
+#include <cstddef>
+#include <string>
+
+#include <napi/native_api.h>
+
+#include "base_context.h"
+#include "event_manager.h"
+#include "tls.h"
+#include "tls_socket_server.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocketServer {
+class TLSServerCloseContext final : public BaseContext {
+public:
+    TLSServerCloseContext() = delete;
+    explicit TLSServerCloseContext(napi_env env, EventManager *manager);
+
+public:
+    int32_t clientId_ = 0;
+    int32_t errorNumber_ = 0;
+
+public:
+    void ParseParams(napi_value *params, size_t paramsCount);
+
+private:
+    bool CheckParamsType(napi_value *params, size_t paramsCount);
+};
+} // namespace TlsSocketServer
+} // namespace NetStack
+} // namespace OHOS
+#endif // TLS_CONTEXT_SEREVR_CLOSE_CONTEXT_H
diff --git a/frameworks/js/napi/tls/include/context/tls_server_napi_context.h b/frameworks/js/napi/tls/include/context/tls_server_napi_context.h
new file mode 100644
index 0000000000000000000000000000000000000000..b02100185f9b0fdee47afedef483047624f29105
--- /dev/null
+++ b/frameworks/js/napi/tls/include/context/tls_server_napi_context.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef TLS_CONTEXT_SERVER_NAPI_CONTEXT_H
+#define TLS_CONTEXT_SERVER_NAPI_CONTEXT_H
+
+#include <cstddef>
+#include <string>
+#include <vector>
+
+#include <napi/native_api.h>
+
+#include "base_context.h"
+#include "event_manager.h"
+#include "net_address.h"
+#include "socket_state_base.h"
+#include "tls.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocketServer {
+class TLSServerNapiContext final : public BaseContext {
+public:
+    TLSServerNapiContext() = delete;
+    explicit TLSServerNapiContext(napi_env env, EventManager *manager);
+
+public:
+    int32_t clientId_ = 0;
+    int32_t errorNumber_ = 0;
+    Socket::NetAddress address_;
+    TlsSocket::X509CertRawData remoteCert_;
+    std::vector<std::string> cipherSuites_;
+    std::vector<std::string> signatureAlgorithms_;
+
+public:
+    void ParseParams(napi_value *params, size_t paramsCount);
+
+private:
+    bool CheckParamsType(napi_value *params, size_t paramsCount);
+};
+
+using ServerTLSGetRemoteAddressContext = TLSServerNapiContext;
+using ServerGetRemoteCertificateContext = TLSServerNapiContext;
+using ServerGetCipherSuitesContext = TLSServerNapiContext;
+using ServerGetSignatureAlgorithmsContext = TLSServerNapiContext;
+} // namespace TlsSocketServer
+} // namespace NetStack
+} // namespace OHOS
+#endif // TLS_CONTEXT_SERVER_NAPI_CONTEXT_H
diff --git a/frameworks/js/napi/tls/include/context/tls_server_send_context.h b/frameworks/js/napi/tls/include/context/tls_server_send_context.h
new file mode 100644
index 0000000000000000000000000000000000000000..90dc8461966b288a72964f9709360ca5f36cad67
--- /dev/null
+++ b/frameworks/js/napi/tls/include/context/tls_server_send_context.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef TLS_CONTEXT_SERVER_SEND_CONTEXT_H
+#define TLS_CONTEXT_SERVER_SEND_CONTEXT_H
+
+#include <cstddef>
+#include <string>
+
+#include <napi/native_api.h>
+
+#include "base_context.h"
+#include "event_manager.h"
+#include "tls.h"
+#include "tls_socket_server.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocketServer {
+class TLSServerSendContext final : public BaseContext {
+public:
+    TLSServerSendContext() = delete;
+    explicit TLSServerSendContext(napi_env env, EventManager *manager);
+
+public:
+    std::string m_sendData = "";
+    int32_t errorNumber_ = 0;
+    int32_t clientId_ = 0;
+
+public:
+    void ParseParams(napi_value *params, size_t paramsCount);
+
+private:
+    bool CheckParamsType(napi_value *params, size_t paramsCount);
+};
+} // namespace TlsSocketServer
+} // namespace NetStack
+} // namespace OHOS
+#endif // TLS_CONTEXT_SERVER_SEND_CONTEXT_H
diff --git a/frameworks/js/napi/tls/include/tlssocketserver_async_work.h b/frameworks/js/napi/tls/include/tlssocketserver_async_work.h
new file mode 100644
index 0000000000000000000000000000000000000000..27171238aa18f066aa8ab6feb84f6db8c82b01c8
--- /dev/null
+++ b/frameworks/js/napi/tls/include/tlssocketserver_async_work.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef TLS_TLSSOCKETSERVER_ASYNC_WORK_H
+#define TLS_TLSSOCKETSERVER_ASYNC_WORK_H
+
+#include <napi/native_api.h>
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocketServer {
+class TLSSocketServerAsyncWork final {
+public:
+    TLSSocketServerAsyncWork() = delete;
+    ~TLSSocketServerAsyncWork() = delete;
+
+    static void ExecGetCertificate(napi_env env, void *data);
+    static void ExecListen(napi_env env, void *data);
+    static void ExecGetCipherSuites(napi_env env, void *data);
+    static void ExecGetRemoteCertificate(napi_env env, void *data);
+    static void ExecGetProtocol(napi_env env, void *data);
+    static void ExecGetSignatureAlgorithms(napi_env env, void *data);
+    static void ExecSend(napi_env env, void *data);
+    static void ExecClose(napi_env env, void *data);
+    static void ExecStop(napi_env env, void *data);
+    static void ExecGetState(napi_env env, void *data);
+    static void ExecGetRemoteAddress(napi_env env, void *data);
+    static void ExecSetExtraOptions(napi_env env, void *data);
+
+    static void GetCertificateCallback(napi_env env, napi_status status, void *data);
+    static void ListenCallback(napi_env env, napi_status status, void *data);
+    static void GetCipherSuitesCallback(napi_env env, napi_status status, void *data);
+    static void GetRemoteCertificateCallback(napi_env env, napi_status status, void *data);
+    static void GetProtocolCallback(napi_env env, napi_status status, void *data);
+    static void GetSignatureAlgorithmsCallback(napi_env env, napi_status status, void *data);
+    static void SendCallback(napi_env env, napi_status status, void *data);
+    static void CloseCallback(napi_env env, napi_status status, void *data);
+    static void StopCallback(napi_env env, napi_status status, void *data);
+    static void GetStateCallback(napi_env env, napi_status status, void *data);
+    static void GetRemoteAddressCallback(napi_env env, napi_status status, void *data);
+    static void SetExtraOptionsCallback(napi_env env, napi_status status, void *data);
+};
+} // namespace TlsSocketServer
+} // namespace NetStack
+} // namespace OHOS
+#endif // TLS_TLSSOCKETSERVER_ASYNC_WORK_H
diff --git a/frameworks/js/napi/tls/include/tlssocketserver_exec.h b/frameworks/js/napi/tls/include/tlssocketserver_exec.h
index f7311f0bea8c4aca0f369e6753ec71f399f8d7ba..861a0091d1475385ba8ab7a74d15a4b53ee4761d 100644
--- a/frameworks/js/napi/tls/include/tlssocketserver_exec.h
+++ b/frameworks/js/napi/tls/include/tlssocketserver_exec.h
@@ -25,7 +25,7 @@
 #include "tls_napi_context.h"
 #include "tls_server_close_context.h"
 #include "tls_server_napi_context.h"
-#include "tls_server_send_contex.h"
+#include "tls_server_send_context.h"
 
 namespace OHOS {
 namespace NetStack {
diff --git a/frameworks/js/napi/tls/src/context/tls_connect_context.cpp b/frameworks/js/napi/tls/src/context/tls_connect_context.cpp
index 689e60294831badb864ed883ff0c56a6ba6eddf8..b072e11873b126e1c9086eb2cdd6521533c6861a 100644
--- a/frameworks/js/napi/tls/src/context/tls_connect_context.cpp
+++ b/frameworks/js/napi/tls/src/context/tls_connect_context.cpp
@@ -41,6 +41,7 @@ constexpr const char *CIPHER_SUITE = "cipherSuite";
 constexpr const char *ADDRESS_NAME = "address";
 constexpr const char *FAMILY_NAME = "family";
 constexpr const char *PORT_NAME = "port";
+constexpr const char *VERIFY_MODE_NAME = "veriyfMode";
 constexpr uint32_t CA_CHAIN_LENGTH = 10;
 constexpr uint32_t PROTOCOLS_SIZE = 10;
 constexpr std::string_view PARSE_ERROR = "options is not type of TLSConnectOptions";
@@ -76,6 +77,9 @@ bool ReadNecessaryOptions(napi_env env, napi_value secureOptions, TLSSecureOptio
     if (NapiUtils::HasNamedProperty(env, secureOptions, CERT_NAME)) {
         secureOption.SetCert(NapiUtils::GetStringPropertyUtf8(env, secureOptions, CERT_NAME));
     }
+    if (NapiUtils::HasNamedProperty(env, secureOptions, VERIFY_MODE_NAME)) {
+        secureOption.SetVerifyMode((VerifyMode)NapiUtils::GetUint32Property(env, secureOptions, VERIFY_MODE_NAME));
+    }
     return true;
 }
 } // namespace
diff --git a/frameworks/js/napi/tls/src/context/tls_server_close_context.cpp b/frameworks/js/napi/tls/src/context/tls_server_close_context.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..75ca5b07b3643f2f62fa959bd6c14a3e95ab4520
--- /dev/null
+++ b/frameworks/js/napi/tls/src/context/tls_server_close_context.cpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "tls_server_close_context.h"
+
+#include <cstdint>
+#include <string_view>
+
+#include "constant.h"
+#include "napi_utils.h"
+#include "netstack_log.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocketServer {
+static constexpr std::string_view PARSE_ERROR = "data is not int";
+
+TLSServerCloseContext::TLSServerCloseContext(napi_env env, EventManager *manager) : BaseContext(env, manager) {}
+
+void TLSServerCloseContext::ParseParams(napi_value *params, size_t paramsCount)
+{
+    if (!CheckParamsType(params, paramsCount)) {
+        return;
+    }
+    if (paramsCount == TlsSocket::PARAM_OPTIONS_AND_CALLBACK) {
+        SetParseOK(SetCallback(params[TlsSocket::ARG_INDEX_0]) == napi_ok);
+        return;
+    }
+    SetParseOK(true);
+}
+
+bool TLSServerCloseContext::CheckParamsType(napi_value *params, size_t paramsCount)
+{
+    if (paramsCount == TlsSocket::PARAM_JUST_OPTIONS) {
+        if (NapiUtils::GetValueType(GetEnv(), params[TlsSocket::ARG_INDEX_0]) != napi_function) {
+            NETSTACK_LOGE("first param is not string");
+            SetNeedThrowException(true);
+            SetError(PARSE_ERROR_CODE, PARSE_ERROR.data());
+            return false;
+        }
+        return true;
+    }
+
+    if (paramsCount == TlsSocket::PARAM_OPTIONS_AND_CALLBACK) {
+        if (NapiUtils::GetValueType(GetEnv(), params[TlsSocket::ARG_INDEX_0]) != napi_number) {
+            NETSTACK_LOGE("first param is not int");
+            SetNeedThrowException(true);
+            SetError(PARSE_ERROR_CODE, PARSE_ERROR.data());
+            return false;
+        }
+        if (NapiUtils::GetValueType(GetEnv(), params[TlsSocket::ARG_INDEX_1]) != napi_function) {
+            NETSTACK_LOGE("second param is not function");
+            return false;
+        }
+        return true;
+    }
+    return false;
+}
+} // namespace TlsSocketServer
+} // namespace NetStack
+} // namespace OHOS
diff --git a/frameworks/js/napi/tls/src/context/tls_server_napi_context.cpp b/frameworks/js/napi/tls/src/context/tls_server_napi_context.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..ec65d64f73d7e87bb8a725061272372d49ad6203
--- /dev/null
+++ b/frameworks/js/napi/tls/src/context/tls_server_napi_context.cpp
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "tls_server_napi_context.h"
+
+#include <cstdint>
+#include <string_view>
+
+#include "constant.h"
+#include "napi_utils.h"
+#include "netstack_log.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocketServer {
+static constexpr std::string_view PARSE_ERROR = "data is not int";
+
+TLSServerNapiContext::TLSServerNapiContext(napi_env env, EventManager *manager) : BaseContext(env, manager) {}
+
+void TLSServerNapiContext::ParseParams(napi_value *params, size_t paramsCount)
+{
+    if (!CheckParamsType(params, paramsCount)) {
+        return;
+    }
+    if (paramsCount == TlsSocket::PARAM_JUST_CALLBACK) {
+        SetParseOK(SetCallback(params[TlsSocket::ARG_INDEX_0]) == napi_ok);
+        return;
+    }
+    SetParseOK(true);
+
+    return;
+}
+
+bool TLSServerNapiContext::CheckParamsType(napi_value *params, size_t paramsCount)
+{
+    if (paramsCount == TlsSocket::PARAM_JUST_CALLBACK) {
+        if (NapiUtils::GetValueType(GetEnv(), params[TlsSocket::ARG_INDEX_0]) != napi_function) {
+            NETSTACK_LOGE("first param is not string");
+            SetNeedThrowException(true);
+            SetError(PARSE_ERROR_CODE, PARSE_ERROR.data());
+            return false;
+        }
+        return true;
+    }
+
+    if (paramsCount == TlsSocket::PARAM_OPTIONS_AND_CALLBACK) {
+        if (NapiUtils::GetValueType(GetEnv(), params[TlsSocket::ARG_INDEX_0]) != napi_number) {
+            NETSTACK_LOGE("first param is not int");
+            SetNeedThrowException(true);
+            SetError(PARSE_ERROR_CODE, PARSE_ERROR.data());
+            return false;
+        }
+        if (NapiUtils::GetValueType(GetEnv(), params[TlsSocket::ARG_INDEX_1]) != napi_function) {
+            NETSTACK_LOGE("second param is not function");
+            return false;
+        }
+        return true;
+    }
+    return false;
+}
+} // namespace TlsSocketServer
+} // namespace NetStack
+} // namespace OHOS
diff --git a/frameworks/js/napi/tls/src/context/tls_server_send_context.cpp b/frameworks/js/napi/tls/src/context/tls_server_send_context.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..1a2e6c26bcea71a8dbeb66561ec46496a862525e
--- /dev/null
+++ b/frameworks/js/napi/tls/src/context/tls_server_send_context.cpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "tls_server_send_context.h"
+
+#include <cstdint>
+#include <string>
+#include <string_view>
+#include <vector>
+
+#include "constant.h"
+#include "napi_utils.h"
+#include "netstack_log.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocketServer {
+namespace {
+constexpr std::string_view PARSE_ERROR = "options is not type of TLSServerSendOptions";
+} // namespace
+
+TLSServerSendContext::TLSServerSendContext(napi_env env, EventManager *manager) : BaseContext(env, manager) {}
+
+void TLSServerSendContext::ParseParams(napi_value *params, size_t paramsCount)
+{
+    if (!CheckParamsType(params, paramsCount)) {
+        return;
+    }
+
+    m_sendData = NapiUtils::GetStringFromValueUtf8(GetEnv(), params[0]);
+
+    if (paramsCount == TlsSocket::PARAM_OPTIONS_AND_CALLBACK) {
+        SetParseOK(SetCallback(params[TlsSocket::ARG_INDEX_1]) == napi_ok);
+        return;
+    }
+    SetParseOK(true);
+}
+
+bool TLSServerSendContext::CheckParamsType(napi_value *params, size_t paramsCount)
+{
+    if (paramsCount == TlsSocket::PARAM_JUST_OPTIONS) {
+        if (NapiUtils::GetValueType(GetEnv(), params[TlsSocket::ARG_INDEX_0]) != napi_string) {
+            NETSTACK_LOGE("first param is not string");
+            SetNeedThrowException(true);
+            SetError(PARSE_ERROR_CODE, PARSE_ERROR.data());
+            return false;
+        }
+        return true;
+    }
+
+    if (paramsCount == TlsSocket::PARAM_OPTIONS_AND_CALLBACK) {
+        if (NapiUtils::GetValueType(GetEnv(), params[TlsSocket::ARG_INDEX_0]) != napi_string) {
+            NETSTACK_LOGE("first param is not string");
+            SetNeedThrowException(true);
+            SetError(PARSE_ERROR_CODE, PARSE_ERROR.data());
+            return false;
+        }
+        if (NapiUtils::GetValueType(GetEnv(), params[TlsSocket::ARG_INDEX_1]) != napi_function) {
+            NETSTACK_LOGE("second param is not function");
+            return false;
+        }
+        return true;
+    }
+    return false;
+}
+} // namespace TlsSocketServer
+} // namespace NetStack
+} // namespace OHOS
diff --git a/frameworks/js/napi/tls/src/tlssocketserver_async_work.cpp b/frameworks/js/napi/tls/src/tlssocketserver_async_work.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..c3204bae87aca0de751f80413647672bcf449f09
--- /dev/null
+++ b/frameworks/js/napi/tls/src/tlssocketserver_async_work.cpp
@@ -0,0 +1,168 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "tlssocketserver_async_work.h"
+
+#include "base_async_work.h"
+#include "common_context.h"
+#include "netstack_log.h"
+#include "tls_bind_context.h"
+#include "tls_connect_context.h"
+#include "tls_extra_context.h"
+#include "tls_napi_context.h"
+#include "tls_server_close_context.h"
+#include "tls_server_napi_context.h"
+#include "tls_server_send_context.h"
+#include "tlssocketserver_exec.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocketServer {
+void TLSSocketServerAsyncWork::ExecGetCertificate(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<TlsSocket::GetCertificateContext, TLSSocketServerExec::ExecGetCertificate>(env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecListen(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<TlsSocket::TLSListenContext, TLSSocketServerExec::ExecListen>(env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecGetCipherSuites(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<ServerGetCipherSuitesContext, TLSSocketServerExec::ExecGetCipherSuites>(env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecGetRemoteCertificate(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<ServerGetRemoteCertificateContext, TLSSocketServerExec::ExecGetRemoteCertificate>(
+        env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecGetProtocol(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<TlsSocket::GetProtocolContext, TLSSocketServerExec::ExecGetProtocol>(env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecGetSignatureAlgorithms(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<ServerGetSignatureAlgorithmsContext, TLSSocketServerExec::ExecGetSignatureAlgorithms>(
+        env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecSend(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<TLSServerSendContext, TLSSocketServerExec::ExecSend>(env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecClose(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<TLSServerCloseContext, TLSSocketServerExec::ExecClose>(env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecStop(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<TlsSocket::TLSNapiContext, TLSSocketServerExec::ExecStop>(env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecGetState(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<TlsSocket::TLSGetStateContext, TLSSocketServerExec::ExecGetState>(env, data);
+}
+
+void TLSSocketServerAsyncWork::ExecGetRemoteAddress(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<ServerTLSGetRemoteAddressContext, TLSSocketServerExec::ExecGetRemoteAddress>(env,
+                                                                                                              data);
+}
+
+void TLSSocketServerAsyncWork::ExecSetExtraOptions(napi_env env, void *data)
+{
+    BaseAsyncWork::ExecAsyncWork<TlsSocket::TLSSetExtraOptionsContext, TLSSocketServerExec::ExecSetExtraOptions>(env,
+                                                                                                                 data);
+}
+
+void TLSSocketServerAsyncWork::GetCertificateCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<TlsSocket::GetCertificateContext, TLSSocketServerExec::GetCertificateCallback>(
+        env, status, data);
+}
+
+void TLSSocketServerAsyncWork::ListenCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<TlsSocket::TLSListenContext, TLSSocketServerExec::ListenCallback>(env, status,
+                                                                                                       data);
+}
+
+void TLSSocketServerAsyncWork::GetCipherSuitesCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<ServerGetCipherSuitesContext, TLSSocketServerExec::GetCipherSuitesCallback>(
+        env, status, data);
+}
+
+void TLSSocketServerAsyncWork::GetRemoteCertificateCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<ServerGetRemoteCertificateContext,
+                                     TLSSocketServerExec::GetRemoteCertificateCallback>(env, status, data);
+}
+
+void TLSSocketServerAsyncWork::GetProtocolCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<TlsSocket::GetProtocolContext, TLSSocketServerExec::GetProtocolCallback>(
+        env, status, data);
+}
+
+void TLSSocketServerAsyncWork::GetSignatureAlgorithmsCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<ServerGetSignatureAlgorithmsContext,
+                                     TLSSocketServerExec::GetSignatureAlgorithmsCallback>(env, status, data);
+}
+
+void TLSSocketServerAsyncWork::SendCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<TLSServerSendContext, TLSSocketServerExec::SendCallback>(env, status, data);
+}
+
+void TLSSocketServerAsyncWork::CloseCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<TLSServerCloseContext, TLSSocketServerExec::CloseCallback>(env, status, data);
+}
+
+void TLSSocketServerAsyncWork::StopCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<TlsSocket::TLSNapiContext, TLSSocketServerExec::StopCallback>(env, status, data);
+}
+
+void TLSSocketServerAsyncWork::GetStateCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<TlsSocket::TLSGetStateContext, TLSSocketServerExec::GetStateCallback>(env, status,
+                                                                                                           data);
+}
+
+void TLSSocketServerAsyncWork::GetRemoteAddressCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<ServerTLSGetRemoteAddressContext, TLSSocketServerExec::GetRemoteAddressCallback>(
+        env, status, data);
+}
+
+void TLSSocketServerAsyncWork::SetExtraOptionsCallback(napi_env env, napi_status status, void *data)
+{
+    BaseAsyncWork::AsyncWorkCallback<TlsSocket::TLSSetExtraOptionsContext,
+                                     TLSSocketServerExec::SetExtraOptionsCallback>(env, status, data);
+}
+
+} // namespace TlsSocketServer
+} // namespace NetStack
+} // namespace OHOS
diff --git a/frameworks/js/napi/tls/src/tlssocketserver_exec.cpp b/frameworks/js/napi/tls/src/tlssocketserver_exec.cpp
index 89b7b7b4a875fc5849e3322b6ad835c2dea2efc4..f00574f3c02ee59f9c132c5275ead00498d03a12 100644
--- a/frameworks/js/napi/tls/src/tlssocketserver_exec.cpp
+++ b/frameworks/js/napi/tls/src/tlssocketserver_exec.cpp
@@ -222,7 +222,7 @@ bool TLSSocketServerExec::ExecClose(TLSServerCloseContext *context)
                           TlsSocket::MakeErrorMessage(TlsSocket::TlsSocketError::TLS_ERR_NO_BIND));
         return false;
     }
-    tlsSocketServer->Close(context->clientFd_, [&context](int32_t errorNumber) {
+    tlsSocketServer->Close(context->clientId_, [&context](int32_t errorNumber) {
         context->errorNumber_ = errorNumber;
         if (errorNumber != TlsSocket::TlsSocketError::TLSSOCKET_SUCCESS) {
             context->SetError(errorNumber, TlsSocket::MakeErrorMessage(errorNumber));
diff --git a/frameworks/native/tls_socket/include/tls_configuration.h b/frameworks/native/tls_socket/include/tls_configuration.h
index 51b41cd3de289f771beb0724e17463a0d06322b5..a9e05a727db20629dccc1c7d148d14db7b3854f0 100644
--- a/frameworks/native/tls_socket/include/tls_configuration.h
+++ b/frameworks/native/tls_socket/include/tls_configuration.h
@@ -20,9 +20,9 @@
 #include <string>
 #include <vector>
 
+#include "tls.h"
 #include "tls_certificate.h"
 #include "tls_key.h"
-
 namespace OHOS {
 namespace NetStack {
 namespace TlsSocket {
@@ -64,6 +64,9 @@ public:
     [[nodiscard]] const std::string &GetSignatureAlgorithms() const;
     [[nodiscard]] std::vector<CipherSuite> GetCipherSuiteVec() const;
 
+    void SetVerifyMode(VerifyMode verifyMode);
+    [[nodiscard]] VerifyMode GetVerifyMode() const;
+
 private:
     TLSProtocol minProtocol_ = TLS_V1_3;
     TLSProtocol maxProtocol_ = TLS_V1_3;
@@ -81,6 +84,7 @@ private:
     TLSCertificate localCertificate_;
     TLSCertificate caCertificate_;
     std::vector<std::string> caCertificateChain_;
+    VerifyMode tlsVerifyMode_;
 };
 } // namespace TlsSocket
 } // namespace NetStack
diff --git a/frameworks/native/tls_socket/include/tls_context_server.h b/frameworks/native/tls_socket/include/tls_context_server.h
new file mode 100644
index 0000000000000000000000000000000000000000..cbf434f414a5bc3e6117e3c0b9234d62ddefc6f5
--- /dev/null
+++ b/frameworks/native/tls_socket/include/tls_context_server.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef COMMUNICATION_NETSTACK_TLS_CONTEXT_SERVER_H
+#define COMMUNICATION_NETSTACK_TLS_CONTEXT_SERVER_H
+
+#include <memory>
+
+#include "tls.h"
+#include "tls_configuration.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocket {
+class TLSContextServer {
+public:
+    TLSContextServer() = default;
+    ~TLSContextServer() = default;
+    static std::unique_ptr<TLSContextServer> CreateConfiguration(const TLSConfiguration &configuration);
+    SSL *CreateSsl();
+    void CloseCtx();
+
+private:
+    static bool InitTlsContext(TLSContextServer *sslContext, const TLSConfiguration &configuration);
+    static bool SetCipherList(TLSContextServer *tlsContext, const TLSConfiguration &configuration);
+    static bool SetSignatureAlgorithms(TLSContextServer *tlsContext, const TLSConfiguration &configuration);
+    static void GetCiphers(TLSContextServer *tlsContext);
+    static void UseRemoteCipher(TLSContextServer *tlsContext);
+    static void SetMinAndMaxProtocol(TLSContextServer *tlsContext);
+    static bool SetCaAndVerify(TLSContextServer *tlsContext, const TLSConfiguration &configuration);
+    static bool SetLocalCertificate(TLSContextServer *tlsContext, const TLSConfiguration &configuration);
+    static bool SetKeyAndCheck(TLSContextServer *tlsContext, const TLSConfiguration &configuration);
+    static void SetVerify(TLSContextServer *tlsContext);
+
+private:
+    SSL_CTX *ctx_ = nullptr;
+    EVP_PKEY *pkey_ = nullptr;
+    SSL *ctxSsl_ = nullptr;
+    TLSConfiguration tlsConfiguration_;
+    static VerifyMode verifyMode_;
+};
+} // namespace TlsSocket
+} // namespace NetStack
+} // namespace OHOS
+#endif // COMMUNICATION_NETSTACK_TLS_CONTEXT_H
diff --git a/frameworks/native/tls_socket/src/tls_configuration.cpp b/frameworks/native/tls_socket/src/tls_configuration.cpp
index c122f6d08ba49159c6c0e6be90afa2a863842b57..d851b46fb1ce7310b57fa7be25d37d090983fedb 100644
--- a/frameworks/native/tls_socket/src/tls_configuration.cpp
+++ b/frameworks/native/tls_socket/src/tls_configuration.cpp
@@ -32,6 +32,7 @@ TLSConfiguration::TLSConfiguration(const TLSConfiguration &other)
     minProtocol_ = other.minProtocol_;
     maxProtocol_ = other.maxProtocol_;
     cipherSuite_ = other.cipherSuite_;
+    tlsVerifyMode_ = other.tlsVerifyMode_;
 }
 
 const TLSKey &TLSConfiguration::PrivateKey() const
@@ -50,6 +51,7 @@ TLSConfiguration &TLSConfiguration::operator=(const TLSConfiguration &other)
     caCertificateChain_ = other.caCertificateChain_;
     signatureAlgorithms_ = other.signatureAlgorithms_;
     privateKey_ = other.privateKey_;
+    tlsVerifyMode_ = other.tlsVerifyMode_;
     return *this;
 }
 
@@ -177,6 +179,14 @@ TLSKey TLSConfiguration::GetPrivateKey() const
 {
     return privateKey_;
 }
+void TLSConfiguration::SetVerifyMode(VerifyMode verifyMode)
+{
+    tlsVerifyMode_ = verifyMode;
+}
+VerifyMode TLSConfiguration::GetVerifyMode() const
+{
+    return tlsVerifyMode_;
+}
 } // namespace TlsSocket
 } // namespace NetStack
 } // namespace OHOS
diff --git a/frameworks/native/tls_socket/src/tls_context_server.cpp b/frameworks/native/tls_socket/src/tls_context_server.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..bb41b9f0d8ad6d2e773c48b6b570ab1fd4bd6777
--- /dev/null
+++ b/frameworks/native/tls_socket/src/tls_context_server.cpp
@@ -0,0 +1,310 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "tls_context_server.h"
+
+#include <cerrno>
+#include <cinttypes>
+#include <string>
+
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/ssl.h>
+
+#include "netstack_log.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocket {
+VerifyMode TLSContextServer::verifyMode_ = TWO_WAY_MODE;
+std::unique_ptr<TLSContextServer> TLSContextServer::CreateConfiguration(const TLSConfiguration &configuration)
+{
+    auto tlsContext = std::make_unique<TLSContextServer>();
+    if (!InitTlsContext(tlsContext.get(), configuration)) {
+        NETSTACK_LOGE("Failed to init tls context");
+        return nullptr;
+    }
+    return tlsContext;
+}
+
+void InitEnvServer()
+{
+    SSL_library_init();
+    OpenSSL_add_all_algorithms();
+    SSL_load_error_strings();
+}
+
+bool TLSContextServer::SetCipherList(TLSContextServer *tlsContext, const TLSConfiguration &configuration)
+{
+    if (!tlsContext) {
+        NETSTACK_LOGE("tlsContext is null");
+        return false;
+    }
+    NETSTACK_LOGD("GetCipherSuite = %{public}s", configuration.GetCipherSuite().c_str());
+    if (SSL_CTX_set_cipher_list(tlsContext->ctx_, configuration.GetCipherSuite().c_str()) <= 0) {
+        NETSTACK_LOGE("Error setting the cipher list");
+        return false;
+    }
+    return true;
+}
+
+void TLSContextServer::GetCiphers(TLSContextServer *tlsContext)
+{
+    if (!tlsContext) {
+        NETSTACK_LOGE("tlsContext is null");
+        return;
+    }
+    std::vector<CipherSuite> cipherSuiteVec;
+    STACK_OF(SSL_CIPHER) *sslCipters = SSL_CTX_get_ciphers(tlsContext->ctx_);
+    if (!sslCipters) {
+        NETSTACK_LOGE("sslCipters is null");
+        return;
+    }
+    CipherSuite cipherSuite;
+    for (int i = 0; i < sk_SSL_CIPHER_num(sslCipters); i++) {
+        const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(sslCipters, i);
+        cipherSuite.cipherId_ = SSL_CIPHER_get_id(cipher);
+        cipherSuite.cipherName_ = SSL_CIPHER_get_name(cipher);
+        cipherSuiteVec.push_back(cipherSuite);
+    }
+}
+
+bool TLSContextServer::SetSignatureAlgorithms(TLSContextServer *tlsContext, const TLSConfiguration &configuration)
+{
+    if (!tlsContext) {
+        NETSTACK_LOGE("tlsContext is null");
+        return false;
+    }
+    if (configuration.GetSignatureAlgorithms().empty()) {
+        NETSTACK_LOGE("configuration get signature algorithms is empty");
+        return false;
+    }
+
+    if (!SSL_CTX_set1_sigalgs_list(tlsContext->ctx_, configuration.GetSignatureAlgorithms().c_str())) {
+        NETSTACK_LOGE("Error setting the Signature Algorithms");
+        return false;
+    }
+    return true;
+}
+
+void TLSContextServer::UseRemoteCipher(TLSContextServer *tlsContext)
+{
+    if (!tlsContext) {
+        NETSTACK_LOGE("TLSContextServer::UseRemoteCipher: tlsContext is null");
+        return;
+    }
+    if (tlsContext->tlsConfiguration_.GetUseRemoteCipherPrefer()) {
+        SSL_CTX_set_options(tlsContext->ctx_, SSL_OP_CIPHER_SERVER_PREFERENCE);
+    }
+    NETSTACK_LOGI("SSL_CTX_get_options = %{public}" PRIx64,
+                  static_cast<uint64_t>(SSL_CTX_get_options(tlsContext->ctx_)));
+}
+
+void TLSContextServer::SetMinAndMaxProtocol(TLSContextServer *tlsContext)
+{
+    if (!tlsContext) {
+        NETSTACK_LOGE("TLSContextServer::SetMinAndMaxProtocol: tlsContext is null");
+        return;
+    }
+    const long anyVersion = TLS_ANY_VERSION;
+    long minVersion = anyVersion;
+    long maxVersion = anyVersion;
+
+    switch (tlsContext->tlsConfiguration_.GetMinProtocol()) {
+        case TLS_V1_2:
+            minVersion = TLS1_2_VERSION;
+            break;
+        case TLS_V1_3:
+            minVersion = TLS1_3_VERSION;
+            break;
+        case UNKNOW_PROTOCOL:
+            break;
+        default:
+            break;
+    }
+
+    switch (tlsContext->tlsConfiguration_.GetMaxProtocol()) {
+        case TLS_V1_2:
+            maxVersion = TLS1_2_VERSION;
+            break;
+        case TLS_V1_3:
+            maxVersion = TLS1_3_VERSION;
+            break;
+        case UNKNOW_PROTOCOL:
+            break;
+        default:
+            break;
+    }
+
+    if (minVersion != anyVersion && !SSL_CTX_set_min_proto_version(tlsContext->ctx_, minVersion)) {
+        NETSTACK_LOGE("Error while setting the minimal protocol version");
+        return;
+    }
+
+    if (maxVersion != anyVersion && !SSL_CTX_set_max_proto_version(tlsContext->ctx_, maxVersion)) {
+        NETSTACK_LOGE("Error while setting the maximum protocol version");
+        return;
+    }
+
+    NETSTACK_LOGD("minProtocol = %{public}lx, maxProtocol = %{public}lx",
+                  SSL_CTX_get_min_proto_version(tlsContext->ctx_), SSL_CTX_get_max_proto_version(tlsContext->ctx_));
+}
+
+bool TLSContextServer::SetCaAndVerify(TLSContextServer *tlsContext, const TLSConfiguration &configuration)
+{
+    NETSTACK_LOGI("SetCaAndVerify  ");
+
+    if (!tlsContext) {
+        NETSTACK_LOGE("tlsContext is null");
+        return false;
+    }
+    for (const auto &cert : configuration.GetCaCertificate()) {
+        TLSCertificate ca(cert, CA_CERT);
+        if (!X509_STORE_add_cert(SSL_CTX_get_cert_store(tlsContext->ctx_), static_cast<X509 *>(ca.handle()))) {
+            NETSTACK_LOGE("Failed to add x509 cert");
+            return false;
+        }
+    }
+
+    NETSTACK_LOGI("SetCaAndVerify  ok");
+    return true;
+}
+
+bool TLSContextServer::SetLocalCertificate(TLSContextServer *tlsContext, const TLSConfiguration &configuration)
+{
+    if (!tlsContext) {
+        NETSTACK_LOGE("tlsContext is null");
+        return false;
+    }
+    if (!SSL_CTX_use_certificate(tlsContext->ctx_, static_cast<X509 *>(configuration.GetLocalCertificate().handle()))) {
+        NETSTACK_LOGD("The local certificate is unavailable");
+        return false;
+    }
+    return true;
+}
+
+bool TLSContextServer::SetKeyAndCheck(TLSContextServer *tlsContext, const TLSConfiguration &configuration)
+{
+    if (!tlsContext) {
+        NETSTACK_LOGE("The parameter tlsContext is null");
+        return false;
+    }
+    if (configuration.GetPrivateKey().Algorithm() == OPAQUE) {
+        tlsContext->pkey_ = reinterpret_cast<EVP_PKEY *>(configuration.GetPrivateKey().handle());
+    } else {
+        tlsContext->pkey_ = EVP_PKEY_new();
+        if (configuration.GetPrivateKey().Algorithm() == ALGORITHM_RSA) {
+            EVP_PKEY_set1_RSA(tlsContext->pkey_, reinterpret_cast<RSA *>(configuration.GetPrivateKey().handle()));
+        } else if (tlsContext->tlsConfiguration_.GetPrivateKey().Algorithm() == ALGORITHM_DSA) {
+            EVP_PKEY_set1_DSA(tlsContext->pkey_, reinterpret_cast<DSA *>(configuration.GetPrivateKey().handle()));
+        }
+    }
+
+    if (configuration.GetPrivateKey().Algorithm() == OPAQUE) {
+        tlsContext->pkey_ = nullptr;
+    }
+    auto pkey_ = tlsContext->pkey_;
+    if (!SSL_CTX_use_PrivateKey(tlsContext->ctx_, pkey_)) {
+        NETSTACK_LOGE("SSL_CTX_use_PrivateKey is error");
+        return false;
+    }
+
+    if (!configuration.GetPrivateKey().GetKeyPass().Length()) {
+        SSL_CTX_set_default_passwd_cb_userdata(tlsContext->ctx_,
+                                               reinterpret_cast<void *>(const_cast<char *>(
+                                                   tlsContext->tlsConfiguration_.GetPrivateKey().GetKeyPass().Data())));
+    }
+    // Check if the certificate matches the private key.
+    if (!SSL_CTX_check_private_key(tlsContext->ctx_)) {
+        NETSTACK_LOGE("Check if the certificate matches the private key is error");
+        return false;
+    }
+    return true;
+}
+
+void TLSContextServer::SetVerify(TLSContextServer *tlsContext)
+{
+    if (!tlsContext) {
+        NETSTACK_LOGE("tlsContext is null");
+        return;
+    }
+
+    NETSTACK_LOGE("  TLSContextServer::SetVerify tlsContext  %{public}d",
+                  tlsContext->tlsConfiguration_.GetVerifyMode());
+    if (tlsContext->tlsConfiguration_.GetVerifyMode() == ONE_WAY_MODE) {
+        SSL_CTX_set_verify(tlsContext->ctx_, SSL_VERIFY_PEER, nullptr);
+        verifyMode_ = ONE_WAY_MODE;
+    } else {
+        verifyMode_ = TWO_WAY_MODE;
+        SSL_CTX_set_verify(tlsContext->ctx_, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
+    }
+
+    NETSTACK_LOGD("Authentication mode is %{public}s",
+                  verifyMode_ ? "two-way authentication" : "one-way authentication");
+}
+
+bool TLSContextServer::InitTlsContext(TLSContextServer *tlsContext, const TLSConfiguration &configuration)
+{
+    if (!tlsContext) {
+        NETSTACK_LOGE("tlsContext is null");
+        return false;
+    }
+    InitEnvServer();
+    tlsContext->tlsConfiguration_ = configuration;
+    tlsContext->ctx_ = SSL_CTX_new(TLS_server_method());
+    if (tlsContext->ctx_ == nullptr) {
+        NETSTACK_LOGE("ctx is nullptr");
+        return false;
+    }
+    if (!configuration.GetCipherSuite().empty()) {
+        if (!SetCipherList(tlsContext, configuration)) {
+            NETSTACK_LOGE("Failed to set cipher suite");
+            return false;
+        }
+    }
+    if (!configuration.GetSignatureAlgorithms().empty()) {
+        if (!SetSignatureAlgorithms(tlsContext, configuration)) {
+            NETSTACK_LOGE("Failed to set signature algorithms");
+            return false;
+        }
+    }
+    GetCiphers(tlsContext);
+    UseRemoteCipher(tlsContext);
+    SetMinAndMaxProtocol(tlsContext);
+    SetVerify(tlsContext);
+    if (!SetCaAndVerify(tlsContext, configuration)) {
+        return false;
+    }
+    if (!SetLocalCertificate(tlsContext, configuration)) {
+        return false;
+    }
+    if (!SetKeyAndCheck(tlsContext, configuration)) {
+        return false;
+    }
+    return true;
+}
+SSL *TLSContextServer::CreateSsl()
+{
+    ctxSsl_ = SSL_new(ctx_);
+    return ctxSsl_;
+}
+
+void TLSContextServer::CloseCtx()
+{
+    SSL_CTX_free(ctx_);
+}
+} // namespace TlsSocket
+} // namespace NetStack
+} // namespace OHOS
diff --git a/frameworks/native/tls_socket/src/tls_socket.cpp b/frameworks/native/tls_socket/src/tls_socket.cpp
index ce166c4ef59812941bb28d93835cd6118cb96598..0924741e6646ccc943f63b30acd68defcd2ecd0c 100644
--- a/frameworks/native/tls_socket/src/tls_socket.cpp
+++ b/frameworks/native/tls_socket/src/tls_socket.cpp
@@ -16,11 +16,11 @@
 #include "tls_socket.h"
 
 #include <chrono>
+#include <memory>
 #include <numeric>
 #include <regex>
 #include <securec.h>
 #include <thread>
-#include <memory>
 
 #include <netinet/tcp.h>
 #include <openssl/err.h>
@@ -163,6 +163,7 @@ TLSSecureOptions &TLSSecureOptions::operator=(const TLSSecureOptions &tlsSecureO
     signatureAlgorithms_ = tlsSecureOptions.GetSignatureAlgorithms();
     cipherSuite_ = tlsSecureOptions.GetCipherSuite();
     useRemoteCipherPrefer_ = tlsSecureOptions.UseRemoteCipherPrefer();
+    TLSVerifyMode_ = tlsSecureOptions.GetVerifyMode();
     return *this;
 }
 
@@ -256,6 +257,16 @@ const std::vector<std::string> &TLSSecureOptions::GetCrlChain() const
     return crlChain_;
 }
 
+void TLSSecureOptions::SetVerifyMode(VerifyMode verifyMode)
+{
+    TLSVerifyMode_ = verifyMode;
+}
+
+VerifyMode TLSSecureOptions::GetVerifyMode() const
+{
+    return TLSVerifyMode_;
+}
+
 void TLSConnectOptions::SetNetAddress(const Socket::NetAddress &address)
 {
     address_.SetAddress(address.GetAddress());
diff --git a/interfaces/innerkits/tls_socket/include/tls_socket.h b/interfaces/innerkits/tls_socket/include/tls_socket.h
index be4cc1f8efc7d1605bb41e445150a3aea78b1596..0c7c908bc181cc69797b3b2adceeac37e40a6910 100644
--- a/interfaces/innerkits/tls_socket/include/tls_socket.h
+++ b/interfaces/innerkits/tls_socket/include/tls_socket.h
@@ -189,6 +189,10 @@ public:
      */
     [[nodiscard]] const std::vector<std::string> &GetCrlChain() const;
 
+    void SetVerifyMode(VerifyMode verifyMode);
+
+    [[nodiscard]] VerifyMode GetVerifyMode() const;
+
 private:
     std::vector<std::string> caChain_;
     std::string cert_;
@@ -199,6 +203,7 @@ private:
     std::string signatureAlgorithms_;
     std::string cipherSuite_;
     std::vector<std::string> crlChain_;
+    VerifyMode TLSVerifyMode_ = VerifyMode::ONE_WAY_MODE;
 };
 
 /**
diff --git a/interfaces/innerkits/tls_socket/include/tls_socket_server.h b/interfaces/innerkits/tls_socket/include/tls_socket_server.h
new file mode 100644
index 0000000000000000000000000000000000000000..928bc01f3fae1338c2a33435c0773140b470be5a
--- /dev/null
+++ b/interfaces/innerkits/tls_socket/include/tls_socket_server.h
@@ -0,0 +1,440 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef COMMUNICATIONNETSTACK_TLS_SERVER_SOCEKT_H
+#define COMMUNICATIONNETSTACK_TLS_SERVER_SOCEKT_H
+
+#include <any>
+#include <condition_variable>
+#include <cstring>
+#include <functional>
+#include <map>
+#include <thread>
+#include <tuple>
+#include <unistd.h>
+#include <vector>
+
+#include "event_manager.h"
+#include "extra_options_base.h"
+#include "net_address.h"
+#include "socket_error.h"
+#include "socket_remote_info.h"
+#include "socket_state_base.h"
+#include "tcp_connect_options.h"
+#include "tcp_extra_options.h"
+#include "tcp_send_options.h"
+#include "tls.h"
+#include "tls_certificate.h"
+#include "tls_configuration.h"
+#include "tls_context_server.h"
+#include "tls_key.h"
+#include "tls_socket.h"
+
+namespace OHOS {
+namespace NetStack {
+namespace TlsSocketServer {
+using OnMessageCallback =
+    std::function<void(const int &socketFd, const std::string &data, const Socket::SocketRemoteInfo &remoteInfo)>;
+using OnCloseCallback = std::function<void(const int &socketFd)>;
+using OnConnectCallback = std::function<void(const int &socketFd, std::shared_ptr<EventManager> eventManager)>;
+using ListenCallback = std::function<void(int32_t errorNumber)>;
+class TLSServerSendOptions {
+public:
+    /**
+     * Set the socket ID to be transmitted
+     * @param socketFd Communication descriptor
+     */
+    void SetSocket(const int &socketFd);
+
+    /**
+     * Set the data to send
+     * @param data Send data
+     */
+    void SetSendData(const std::string &data);
+
+    /**
+     * Get the socket ID
+     * @return Gets the communication descriptor
+     */
+    [[nodiscard]] const int &GetSocket() const;
+
+    /**
+     * Gets the data sent
+     * @return Send data
+     */
+    [[nodiscard]] const std::string &GetSendData() const;
+
+private:
+    int socketFd_;
+    std::string data_;
+};
+
+class TLSSocketServer {
+public:
+    TLSSocketServer(const TLSSocketServer &) = delete;
+    TLSSocketServer(TLSSocketServer &&) = delete;
+
+    TLSSocketServer &operator=(const TLSSocketServer &) = delete;
+    TLSSocketServer &operator=(TLSSocketServer &&) = delete;
+
+    TLSSocketServer() = default;
+    ~TLSSocketServer() = default;
+
+    /**
+     * Create sockets, bind and listen waiting for clients to connect
+     * @param tlsListenOptions Bind the listening connection configuration
+     * @param callback callback to the caller if bind ok or not
+     */
+    void Listen(const TlsSocket::TLSConnectOptions &tlsListenOptions, const ListenCallback &callback);
+
+    /**
+     * Send data through an established encrypted connection
+     * @param data data sent over an established encrypted connection
+     * @return whether the data is successfully sent to the server
+     */
+    bool Send(const TLSServerSendOptions &data, const TlsSocket::SendCallback &callback);
+
+    /**
+     * Disconnect by releasing the socket when communicating
+     * @param socketFd The socket ID of the client
+     * @param callback callback to the caller
+     */
+    void Close(const int socketFd, const TlsSocket::CloseCallback &callback);
+
+    /**
+     * Disconnect by releasing the socket when communicating
+     * @param callback callback to the caller
+     */
+    void Stop(const TlsSocket::CloseCallback &callback);
+
+    /**
+     * Get the peer network address
+     * @param socketFd The socket ID of the client
+     * @param callback callback to the caller
+     */
+    void GetRemoteAddress(const int socketFd, const TlsSocket::GetRemoteAddressCallback &callback);
+
+    /**
+     * Get the status of the current socket
+     * @param callback callback to the caller
+     */
+    void GetState(const TlsSocket::GetStateCallback &callback);
+
+    /**
+     * Gets or sets the options associated with the current socket
+     * @param tcpExtraOptions options associated with the current socket
+     * @param callback callback to the caller
+     */
+    bool SetExtraOptions(const Socket::TCPExtraOptions &tcpExtraOptions,
+                         const TlsSocket::SetExtraOptionsCallback &callback);
+
+    /**
+     *  Get a local digital certificate
+     * @param callback callback to the caller
+     */
+    void GetCertificate(const TlsSocket::GetCertificateCallback &callback);
+
+    /**
+     * Get the peer digital certificate
+     * @param socketFd The socket ID of the client
+     * @param needChain need chain
+     * @param callback callback to the caller
+     */
+    void GetRemoteCertificate(const int socketFd, const TlsSocket::GetRemoteCertificateCallback &callback);
+
+    /**
+     * Obtain the protocol used in communication
+     * @param callback callback to the caller
+     */
+    void GetProtocol(const TlsSocket::GetProtocolCallback &callback);
+
+    /**
+     * Obtain the cipher suite used in communication
+     * @param socketFd The socket ID of the client
+     * @param callback callback to the caller
+     */
+    void GetCipherSuite(const int socketFd, const TlsSocket::GetCipherSuiteCallback &callback);
+
+    /**
+     * Obtain the encryption algorithm used in the communication process
+     * @param socketFd The socket ID of the client
+     * @param callback callback to the caller
+     */
+    void GetSignatureAlgorithms(const int socketFd, const TlsSocket::GetSignatureAlgorithmsCallback &callback);
+
+    /**
+     * Register the callback that is called when the connection is disconnected
+     * @param onCloseCallback callback invoked when disconnected
+     */
+
+    /**
+     * Register the callback that is called when the connection is established
+     * @param onConnectCallback callback invoked when connection is established
+     */
+    void OnConnect(const OnConnectCallback &onConnectCallback);
+
+    /**
+     * Register the callback that is called when an error occurs
+     * @param onErrorCallback callback invoked when an error occurs
+     */
+    void OnError(const TlsSocket::OnErrorCallback &onErrorCallback);
+
+    /**
+     * Off Connect
+     */
+    void OffConnect();
+
+    /**
+     * Off Error
+     */
+    void OffError();
+
+private:
+    class Connection : public std::enable_shared_from_this<Connection> {
+    public:
+        /**
+         * Establish an encrypted accept on the specified socket
+         * @param sock socket for establishing encrypted connection
+         * @param options some options required during tls accept
+         * @return whether the encrypted accept is successfully established
+         */
+        bool TlsAcceptToHost(int sock, const TlsSocket::TLSConnectOptions &options);
+
+        /**
+         * Set the configuration items for establishing encrypted connections
+         * @param config configuration item when establishing encrypted connection
+         */
+        void SetTlsConfiguration(const TlsSocket::TLSConnectOptions &config);
+
+        /**
+         * Set address information
+         */
+        void SetAddress(const Socket::NetAddress address);
+
+        /**
+         * Send data through an established encrypted connection
+         * @param data data sent over an established encrypted connection
+         * @return whether the data is successfully sent to the server
+         */
+        bool Send(const std::string &data);
+
+        /**
+         * Receive the data sent by the server through the established encrypted connection
+         * @param buffer receive the data sent by the server
+         * @param maxBufferSize the size of the data received from the server
+         * @return whether the data sent by the server is successfully received
+         */
+        int Recv(char *buffer, int maxBufferSize);
+
+        /**
+         * Disconnect encrypted connection
+         * @return whether the encrypted connection was successfully disconnected
+         */
+        bool Close();
+
+        /**
+         * Set the application layer negotiation protocol in the encrypted communication process
+         * @param alpnProtocols application layer negotiation protocol
+         * @return set whether the application layer negotiation protocol is successful during encrypted communication
+         */
+        bool SetAlpnProtocols(const std::vector<std::string> &alpnProtocols);
+
+        /**
+         * Storage of server communication related network information
+         * @param remoteInfo communication related network information
+         */
+        void MakeRemoteInfo(Socket::SocketRemoteInfo &remoteInfo);
+
+        /**
+         * Get configuration options for encrypted communication process
+         * @return configuration options for encrypted communication processes
+         */
+        [[nodiscard]] TlsSocket::TLSConfiguration GetTlsConfiguration() const;
+
+        /**
+         * Obtain the cipher suite during encrypted communication
+         * @return crypto suite used in encrypted communication
+         */
+        [[nodiscard]] std::vector<std::string> GetCipherSuite() const;
+
+        /**
+         * Obtain the peer certificate used in encrypted communication
+         * @return peer certificate used in encrypted communication
+         */
+        [[nodiscard]] std::string GetRemoteCertificate() const;
+
+        /**
+         * Obtain the peer certificate used in encrypted communication
+         * @return peer certificate serialization data used in encrypted communication
+         */
+        [[nodiscard]] const TlsSocket::X509CertRawData &GetRemoteCertRawData() const;
+
+        /**
+         * Obtain the certificate used in encrypted communication
+         * @return certificate serialization data used in encrypted communication
+         */
+        [[nodiscard]] const TlsSocket::X509CertRawData &GetCertificate() const;
+
+        /**
+         * Get the encryption algorithm used in encrypted communication
+         * @return encryption algorithm used in encrypted communication
+         */
+        [[nodiscard]] std::vector<std::string> GetSignatureAlgorithms() const;
+
+        /**
+         * Obtain the communication protocol used in encrypted communication
+         * @return communication protocol used in encrypted communication
+         */
+        [[nodiscard]] std::string GetProtocol() const;
+
+        /**
+         * Set the information about the shared signature algorithm supported by peers during encrypted communication
+         * @return information about peer supported shared signature algorithms
+         */
+        [[nodiscard]] bool SetSharedSigals();
+
+        /**
+         * Obtain the ssl used in encrypted communication
+         * @return SSL used in encrypted communication
+         */
+        [[nodiscard]] ssl_st *GetSSL() const;
+
+        /**
+         * Get address information
+         * @return Returns the address information of the remote client
+         */
+        [[nodiscard]] Socket::NetAddress GetAddress() const;
+
+        /**
+         * Get address information
+         * @return Returns the address information of the remote client
+         */
+        [[nodiscard]] int GetSocketFd() const;
+
+        /**
+         * Get EventManager information
+         * @return Returns the address information of the remote client
+         */
+        [[nodiscard]] std::shared_ptr<EventManager> GetEventManager() const;
+
+        void OnMessage(const OnMessageCallback &onMessageCallback);
+        /**
+         * Unregister the callback which is called when message is received
+         */
+        void OffMessage();
+
+        void CallOnMessageCallback(int32_t socketFd, const std::string &data,
+                                   const Socket::SocketRemoteInfo &remoteInfo);
+
+        void SetEventManager(std::shared_ptr<EventManager> eventManager);
+
+        void SetClientID(int32_t clientID);
+
+        [[nodiscard]] int GetClientID();
+
+        void CallOnCloseCallback(const int32_t socketFd);
+        void OnClose(const OnCloseCallback &onCloseCallback);
+        OnCloseCallback onCloseCallback_;
+
+        /**
+         * Off Close
+         */
+        void OffClose();
+
+        /**
+         * Register the callback that is called when an error occurs
+         * @param onErrorCallback callback invoked when an error occurs
+         */
+        void OnError(const TlsSocket::OnErrorCallback &onErrorCallback);
+        /**
+         * Off Error
+         */
+        void OffError();
+
+        void CallOnErrorCallback(int32_t err, const std::string &errString);
+
+        TlsSocket::OnErrorCallback onErrorCallback_;
+
+    private:
+        bool StartTlsAccept(const TlsSocket::TLSConnectOptions &options);
+        bool CreatTlsContext();
+        bool StartShakingHands(const TlsSocket::TLSConnectOptions &options);
+        bool GetRemoteCertificateFromPeer();
+        bool SetRemoteCertRawData();
+        std::string CheckServerIdentityLegal(const std::string &hostName, const X509 *x509Certificates);
+
+    private:
+        ssl_st *ssl_ = nullptr;
+        X509 *peerX509_ = nullptr;
+        int32_t socketFd_ = 0;
+
+        TlsSocket::TLSContextServer tlsContext_;
+        TlsSocket::TLSConfiguration connectionConfiguration_;
+        Socket::NetAddress address_;
+        TlsSocket::X509CertRawData remoteRawData_;
+
+        std::string hostName_;
+        std::string remoteCert_;
+        std::string keyPass_;
+
+        std::vector<std::string> signatureAlgorithms_;
+        std::unique_ptr<TlsSocket::TLSContextServer> tlsContextServerPointer_ = nullptr;
+
+        std::shared_ptr<EventManager> eventManager_ = nullptr;
+        int32_t clientID_ = 0;
+        OnMessageCallback onMessageCallback_;
+    };
+
+private:
+    void SetLocalTlsConfiguration(const TlsSocket::TLSConnectOptions &config);
+    int RecvRemoteInfo(int socketFd);
+    void RemoveConnect(int socketFd);
+    void AddConnect(int socketFd, std::shared_ptr<Connection> connection);
+    void CallListenCallback(int32_t err, ListenCallback callback);
+    void CallOnErrorCallback(int32_t err, const std::string &errString);
+
+    void CallGetStateCallback(int32_t err, const Socket::SocketStateBase &state, TlsSocket::GetStateCallback callback);
+    void CallOnConnectCallback(const int32_t socketFd, std::shared_ptr<EventManager> eventManager);
+    void CallSendCallback(int32_t err, TlsSocket::SendCallback callback);
+    bool ExecBind(const Socket::NetAddress &address, const ListenCallback &callback);
+    void ExecAccept(const TlsSocket::TLSConnectOptions &tlsAcceptOptions, const ListenCallback &callback);
+    void MakeIpSocket(sa_family_t family);
+    void GetAddr(const Socket::NetAddress &address, sockaddr_in *addr4, sockaddr_in6 *addr6, sockaddr **addr,
+                 socklen_t *len);
+    static constexpr const size_t MAX_ERROR_LEN = 128;
+    static constexpr const size_t MAX_BUFFER_SIZE = 8192;
+
+private:
+    std::mutex mutex_;
+    std::mutex connectMutex_;
+    int listenSocketFd_ = -1;
+    Socket::NetAddress address_;
+    std::map<int, std::shared_ptr<Connection>> clientIdConnections_;
+    std::map<int, std::shared_ptr<Connection>> connections_;
+    TlsSocket::TLSConfiguration TLSServerConfiguration_;
+
+    OnConnectCallback onConnectCallback_;
+    TlsSocket::OnErrorCallback onErrorCallback_;
+    TlsSocket::TLSConnectOptions tlsListenOptions_;
+
+public:
+    std::shared_ptr<Connection> GetConnectionByClientID(int clientid);
+};
+
+} // namespace TlsSocketServer
+} // namespace NetStack
+} // namespace OHOS
+
+#endif // COMMUNICATIONNETSTACK_TLS_SERVER_SOCEKT_H
