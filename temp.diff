diff --git a/frameworks/js/napi/socket/async_context/include/local_socket_server_context.h b/frameworks/js/napi/socket/async_context/include/local_socket_server_context.h
index db3219d9..152f6ea0 100644
--- a/frameworks/js/napi/socket/async_context/include/local_socket_server_context.h
+++ b/frameworks/js/napi/socket/async_context/include/local_socket_server_context.h
@@ -17,6 +17,9 @@
 #define LOCAL_SOCKET_SERVER_CONTEXT_H
 
 #include <cstddef>
+#if defined(MAC_PLATFORM) || defined(IOS_PLATFORM)
+#include <unistd.h>
+#endif
 #include <map>
 #if !defined(MAC_PLATFORM) && !defined(IOS_PLATFORM)
 #include <sys/epoll.h>
@@ -35,6 +38,10 @@ struct LocalSocketServerManager : public SocketBaseManager {
     static constexpr int MAX_EVENTS = 10;
     static constexpr int EPOLL_TIMEOUT_MS = 500;
     int clientId_ = 0;
+#if defined(MAC_PLATFORM) || defined(IOS_PLATFORM)
+    int threadCounts_ = 0;
+    bool isServerDestruct_ = false;
+#endif
     LocalExtraOptions extraOptions_;
     bool alreadySetExtraOptions_ = false;
     std::atomic_bool isServerDestruct_;
@@ -155,6 +162,23 @@ struct LocalSocketServerManager : public SocketBaseManager {
         std::lock_guard<std::mutex> lock(clientMutex_);
         return acceptFds_.size();
     }
+#if defined(MAC_PLATFORM) || defined(IOS_PLATFORM)
+    EventManager *WaitForManager(int clientId)
+    {
+        EventManager *manager = nullptr;
+        std::unique_lock<std::mutex> lock(clientMutex_);
+        cond_.wait(lock, [&manager, &clientId, this]() {
+            if (auto iter = clientEventManagers_.find(clientId); iter != clientEventManagers_.end()) {
+                manager = iter->second;
+                if (manager->HasEventListener(EVENT_MESSAGE)) {
+                    return true;
+                }
+            }
+            return false;
+        });
+        return manager;
+    }
+#endif
     void NotifyRegisterEvent()
     {
         std::lock_guard<std::mutex> lock(clientMutex_);
@@ -182,6 +206,13 @@ struct LocalSocketServerManager : public SocketBaseManager {
         }
         clientEventManagers_.clear();
     }
+#if defined(MAC_PLATFORM) || defined(IOS_PLATFORM)
+    void IncreaseThreadCounts()
+    {
+        std::lock_guard<std::mutex> lock(finishMutex_);
+        ++threadCounts_;
+    }
+#endif
     void NotifyLoopFinished()
     {
         std::lock_guard<std::mutex> lock(finishMutex_);
diff --git a/frameworks/js/napi/socket/socket_exec/src/local_socket_exec.cpp b/frameworks/js/napi/socket/socket_exec/src/local_socket_exec.cpp
index b2db3fff..0cb2255b 100644
--- a/frameworks/js/napi/socket/socket_exec/src/local_socket_exec.cpp
+++ b/frameworks/js/napi/socket/socket_exec/src/local_socket_exec.cpp
@@ -47,6 +47,10 @@ constexpr int UNKNOW_ERROR = -1;
 
 constexpr int NO_MEMORY = -2;
 
+#if defined(MAC_PLATFORM) || defined(IOS_PLATFORM)
+constexpr int MAX_CLIENTS = 1024;
+#endif
+
 constexpr int ERRNO_BAD_FD = 9;
 
 constexpr int DEFAULT_TIMEOUT_MS = 20000;
@@ -512,6 +516,104 @@ static inline void RecvInErrorCondition(int reason, int clientId, const LocalSoc
     serverManager->RemoveAccept(clientId);
 }
 
+#if !defined(MAC_PLATFORM) && !defined(IOS_PLATFORM)
+static void LocalSocketServerRecvHandler(int connectFd, LocalSocketServerManager *serverManager,
+                                         const LocalSocketMessageCallback &callback, const std::string &path)
+{
+    serverManager->IncreaseThreadCounts();
+    int clientId = serverManager->AddAccept(connectFd);
+    if (serverManager->alreadySetExtraOptions_) {
+        SetLocalSocketOptions(connectFd, serverManager->extraOptions_);
+    }
+    NETSTACK_LOGI("local socket server accept new, fd: %{public}d, id: %{public}d", connectFd, clientId);
+    callback.OnLocalSocketConnectionMessage(clientId, serverManager);
+    EventManager *eventManager = serverManager->WaitForManager(clientId);
+    int sockRecvSize = ConfirmBufferSize(connectFd);
+    auto buffer = std::make_unique<char[]>(sockRecvSize);
+    if (buffer == nullptr) {
+        NETSTACK_LOGE("failed to malloc, connectFd: %{public}d, malloc size: %{public}d", connectFd, sockRecvSize);
+        RecvInErrorCondition(NO_MEMORY, clientId, callback, serverManager);
+        serverManager->NotifyLoopFinished();
+        return;
+    }
+        while (true) {
+        if (memset_s(buffer.get(), sockRecvSize, 0, sockRecvSize) != EOK) {
+            NETSTACK_LOGE("memset_s failed, connectFd: %{public}d, clientId: %{public}d", connectFd, clientId);
+            continue;
+        }
+        int32_t recvSize = recv(connectFd, buffer.get(), sockRecvSize, 0);
+        if (recvSize == 0) {
+            NETSTACK_LOGI("session closed, errno:%{public}d,fd:%{public}d,id:%{public}d", errno, connectFd, clientId);
+            callback.OnCloseMessage(eventManager);
+            serverManager->RemoveAccept(clientId);
+            break;
+        } else if (recvSize < 0) {
+            if (errno != EINTR) {
+                NETSTACK_LOGE("recv error, errno:%{public}d,fd:%{public}d,id:%{public}d", errno, connectFd, clientId);
+                RecvInErrorCondition(errno, clientId, callback, serverManager);
+                break;
+            }
+        } else {
+            NETSTACK_LOGD("recv, fd:%{public}d, size:%{public}d, buf:%{public}s", connectFd, recvSize, buffer.get());
+            void *data = malloc(recvSize);
+            if (data == nullptr) {
+                RecvInErrorCondition(NO_MEMORY, clientId, callback, serverManager);
+                break;
+            }
+            if (memcpy_s(data, recvSize, buffer.get(), recvSize) != EOK ||
+                !callback.OnMessage(eventManager, data, recvSize, path)) {
+                free(data);
+            }
+        }
+    }
+    serverManager->NotifyLoopFinished();
+}
+
+static void LocalSocketServerAccept(LocalSocketServerManager *mgr, const LocalSocketMessageCallback &callback,
+                                    const std::string &path)
+{
+    struct sockaddr_un clientAddress;
+    socklen_t clientAddrLength = sizeof(clientAddress);
+    struct pollfd fds[1] = {{.fd = mgr->sockfd_, .events = POLLIN}};
+    nfds_t num = 1;
+    mgr->IncreaseThreadCounts();
+    while (true) {
+        int ret = poll(fds, num, DEFAULT_POLL_TIMEOUT_MS);
+        if (ret < 0) {
+            NETSTACK_LOGE("poll to accept failed, socket is %{public}d, errno is %{public}d", mgr->sockfd_, errno);
+            callback.OnError(errno);
+            break;
+        }
+        if (mgr->isServerDestruct_) {
+            NETSTACK_LOGI("server object destruction, loop finished");
+            break;
+        }
+        if (fds[0].revents & POLLIN) {
+            int connectFd = accept(mgr->sockfd_, reinterpret_cast<sockaddr *>(&clientAddress), &clientAddrLength);
+            if (connectFd < 0) {
+                continue;
+            }
+            if (mgr->GetClientCounts() >= MAX_CLIENTS) {
+                NETSTACK_LOGE("local socket server max number of clients reached, sockfd: %{public}d", mgr->sockfd_);
+                close(connectFd);
+                continue;
+            }
+            SetSocketDefaultBufferSize(connectFd, mgr);
+            if (!mgr->isServerDestruct_) {
+                std::thread handlerThread(LocalSocketServerRecvHandler, connectFd, mgr, std::ref(callback),
+                                          std::ref(path));
+#if defined(MAC_PLATFORM) || defined(IOS_PLATFORM)
+                pthread_setname_np(LOCAL_SOCKET_SERVER_HANDLE_CLIENT);
+#else
+                pthread_setname_np(handlerThread.native_handle(), LOCAL_SOCKET_SERVER_HANDLE_CLIENT);
+#endif
+                handlerThread.detach();
+            }
+        }
+    }
+}
+#endif
+
 static void RecvHandler(int connectFd, const LocalSocketMessageCallback &callback, LocalSocketServerManager *mgr)
 {
     int clientId = mgr->GetClientId(connectFd);
